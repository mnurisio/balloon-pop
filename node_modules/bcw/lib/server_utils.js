const path = require("path");
const net = require('net');
const fs = require("fs");

const { getContentType } = require("./Mime.js");
const { colors, printAlert } = require("../utils/console-utils.js");

const basePath = process.cwd();

function getOpenPort(port = 8080) {
  const server = net.createServer();
  return new Promise((resolve, reject) => {
    server.listen(port, () => {
      server.once('close', () => {
        resolve(port);
      });
      server.close();
    });
    server.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'EADDRINUSE') {
        let randomPort = Math.floor(Math.random() * (65535 - 49152) + 49152);
        if (randomPort == port) { randomPort++ }
        resolve(getOpenPort(randomPort));
      } else {
        reject(err);
      }
    });
  });
}

function handlePortFlags() {
  try {
    if (process.argv) {
      process.argv.find((a, i) => {
        if (a.includes("-p")) {
          return Number(process.argv[i + 1]);
        }
      });
    }
    return 8080
  } catch (error) {
    return 8080
  }
}

async function handleServerRequests(req, res, liveServer = false, WS_PORT = 8081) {

  if (req.method !== "GET") {
    const responseBody = `Forbidden Method: ${req.method}`;

    res.writeHead(403, {
      "Content-Type": "plain/text",
      "Content-Length": Buffer.byteLength(responseBody),
    });

    return res.end(responseBody);
  }

  const url = new URL(req.url, `http://${req.headers.host}`);
  let pathname = url.pathname;

  // If the pathname ends with '/', append 'index.html'.
  if (pathname.endsWith("/")) {
    pathname += "index.html";
  }

  try {
    // Try to read the given resource into a Buffer.
    const resourcePath = path.join(basePath, pathname);
    let responseBody = await fs.promises.readFile(resourcePath);
    if (resourcePath.endsWith("index.html") && liveServer) {
      // @ts-ignore
      responseBody = responseBody
        .toString()
        .replace("</body>", `<script>const socket = new WebSocket("ws://localhost:${WS_PORT}");
        socket.addEventListener("message", (event) => {
          if (event.data === "RELOAD") {
            window.location.reload();
          }
        });</script></body>`);

      responseBody = Buffer.from(responseBody);
    }

    const headers = {
      "Content-Type": getContentType(resourcePath),
      "Content-Length": responseBody.length,
    }
    res.writeHead(200, headers);
    return res.end(responseBody);

  } catch (e) {
    // Respond to all errors with a 404 response.
    const responseBody = `Cannot GET resource: ${pathname}`;

    res.writeHead(404, {
      "Content-Type": "plain/text",
      "Content-Length": Buffer.byteLength(responseBody),
    });
    return res.end(responseBody);
  }
}

function checkForIndex() {
  let hasIndex = fs.existsSync('index.html')
  if (!hasIndex) {
    printAlert('[!] Missing index.html \n\t[~] Are you serving from the right file location?')
  }
}

async function startServer(server, port = 8080) {
  let PORT = await getOpenPort(port);
  checkForIndex()
  server.listen(PORT, () => {
    console.log(`${colors.FgGreen}---CODEWORKS SERVER-------------------------------------------------------${colors.Reset}
    ${colors.FgYellow}${basePath}${colors.Reset}
    Available on:  ${colors.FgCyan}http://localhost:${PORT}${colors.Reset}
    Quit: ${colors.FgMagenta}ctrl+c${colors.Reset}
  `);
  });

  process.on('SIGINT', function () {
    printAlert('\t[!] Server stopped.');
    process.exit();
  });

  process.on('SIGTERM', function () {
    printAlert('\t[!] Server stopped.');
    process.exit();
  });
}


exports.getOpenPort = getOpenPort;
exports.handlePortFlags = handlePortFlags;
exports.handleServerRequests = handleServerRequests;
exports.startServer = startServer;